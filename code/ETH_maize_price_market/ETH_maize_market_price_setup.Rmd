---
title: "Setup for the Ensemble Prediction of Market Maize Prices in Ethiopia"
author: "Sebastian Palmas"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document:
    toc: true
    toc_depth: 2

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) 
```

# Introduction
Setup for the ensemble prediction of maize market prices in Ethiopia. It creates tables for calibration and validation.

## Packages
We use the "sp", "raster" and "rgdal" R packages for creating and manipulating spatial data in this exercise. They are all add-on packages that have to be installed from CRAN.
```{r, results = 'hide'}
library(dplyr)
library(rgdal)
library(terra)
```

# I. Preparing spatial covariates raterstack
There are multiple spatial covariates. Weather, soil and amenities. Also we add latitude and longitude data.

## 1) Raster Data on Weather, Soil and Amenities
The raster files contain data on weather elements, soil properties and distance to infrastructure/amenities. In this exercise, these files are in a sub-directory of the working directory. You can download them [here](https://osf.io/j8y3z/). The table below gives a short description of each file and a link to the source website.

|Raster | Short description | Derived from:
|:-----|:---------|:-----|
|BIO1 | Mean annual temperature (째C * 10, 1979-2013) | [CHELSA](http://chelsa-climate.org/downloads/)
|BIO7 | Mean annual temperature range (째C * 10, 1979-2013) | [CHELSA](http://chelsa-climate.org/downloads/)
|BIO12 | Mean annual precipitation (mm/yr, 1979-2013) | [CHELSA](http://chelsa-climate.org/downloads/)
|BIO15 | Mean rainfall seasonality (cv, 1979-2013) | [CHELSA](http://chelsa-climate.org/downloads/)
|BPP15 | Predicted 2015 building presence probability | [Africagrids.net](ftp://africagrids.net/)
|CEC | Predicted topsoil cation exchange capacity (cmol/kg) | [SoilGrids](https://soilgrids.org)
|CPP15 | Predicted 2015 cropland presence probability | [Africagrids.net](ftp://africagrids.net/)
|DCELL | Distance to Cell Tower or WiFi point (km) | [UnwiredLabs](https://unwiredlabs.com)
|DFRES | Distance to forest reserves (km) | [Protected Planet](https://www.protectedplanet.net/)
|DGRES | Distance to game reserves (km) | [Protected Planet](https://www.protectedplanet.net/)
|DGRID | Distance to X (km) | [X](ftp://africagrids.net/)
|DHRSL | Distance to High-Resolution Settlement Layer (km) | [CIESIN](https://ciesin.columbia.edu/data/hrsl/)
|DNLT | Distance to BlackMarble night-lights (km) | [NASA](https://earthobservatory.nasa.gov/features/NightLights/page3.php)
|DOR1 | Distance to main roads (km) | [Geofabrik](#https://www.geofabrik.de/data/download.html)
|DOR2 | Distance to any known road (km) | [Geofabrik](#https://www.geofabrik.de/data/download.html)
|DOWS | Distance to inland water bodies (km) | [SurfaceWater](#https://global-surface-water.appspot.com/)
|DPARK | Distance to national parks & conservation areas (km) | [Protected Planet](https://www.protectedplanet.net/)
|DPOP1 | Distance to city or town centers (km) | [Geofabrik](#https://www.geofabrik.de/data/download.html)
|DPOP2 | Distance to village or hamlet centers (km) | [Geofabrik](#https://www.geofabrik.de/data/download.html)
|EVI | Average enhanced vegetation index (2000-2016) | [Africagrids.net](ftp://africagrids.net/)
|FIRE | Detected fire density (2001-2015) | [Africagrids.net](ftp://africagrids.net/)
|GBD | Building footprint densities (2017) | [DigitalGlobe](https://explore.digitalglobe.com/Tanzania-Building-Footprints.html)
|GCCP | USGS cropland extent prediction (2015) | [USGS](https://croplands.org/app/map?lat=0.17578&lng=-0.17578125&zoom=2)
|GFPL | Global floodplain extent (2017) | [USGS](https://www.usgs.gov/centers/eros/science/usgs-eros-archive-landsat-landsat-level-3-dynamic-surface-water-extent-dswe?qt-science_center_objects=0#qt-science_center_objects)
|LCB | Bare /sparse vegetation cover fraction (2015) | [Copernicus](http://lcviewer.vito.be/)
|LCC | Cropland cover fraction (2015) | [Copernicus](http://lcviewer.vito.be/)
|LCS | Shrubland cover fraction (2015) | [Copernicus](http://lcviewer.vito.be/)
|LCT | Forest cover fraction (2015) | [Copernicus](http://lcviewer.vito.be/)
|LCU | Built-up cover fraction (2015) | [Copernicus](http://lcviewer.vito.be/)
|LSTD | Average day-time land surface temp. (째C , 2001-2017) | [Africagrids.net](ftp://africagrids.net/)
|LSTN | Average night-time land surface temp. (째C , 2001-2017) | [Africagrids.net](ftp://africagrids.net/)
|MB1 | Average MOD13Q1 band 1 reflectance (2001-2016)  | [Africagrids.net](ftp://africagrids.net/)
|MB2  | Average MOD13Q1 band 2 reflectance (2001-2016) | [Africagrids.net](ftp://africagrids.net/)
|MB3 | Average MOD13Q1 band 3 reflectance (2001-2016) | [Africagrids.net](ftp://africagrids.net/)
|MB7 | Average MOD13Q1 band 7 reflectance (2001-2016) | [Africagrids.net](ftp://africagrids.net/)
|MDEM | Elevation above mean sea level (m) | [MERITDEM](http://hydro.iis.u-tokyo.ac.jp/~yamadai/MERIT_DEM/)
|NPPA | Average annual net primary productivity (kg/m2, 2000-2015) | [Africagrids.net](ftp://africagrids.net/)
|NPPS | Variance annual net primary productivity (2000-2015) | [Africagrids.net](ftp://africagrids.net/)
|PARA | Average fAPAR (2000-2017) | [Africagrids.net](ftp://africagrids.net/)
|PARV | Variance fAPAR (2000-2017) | [Africagrids.net](ftp://africagrids.net/)
|PH | Predicted topsoil pH | [SoilGrids](https://soilgrids.org)
|S1VV | Average Sentinel 1 VV radar backscatter (2016) | [Africagrids.net](ftp://africagrids.net/)
|S2B11 | Average Sentinel 2 SWIR1 reflectance (2016-2017) | [Africagrids.net](ftp://africagrids.net/)
|S2B12 | Average Sentinel 2 SWIR2 reflectance (2016-2017) | [Africagrids.net](ftp://africagrids.net/)
|SLOPE | Slope (%) | [MERITDEM](http://hydro.iis.u-tokyo.ac.jp/~yamadai/MERIT_DEM/)
|SND | Predicted topsoil sand content (%) | [SoilGrids](https://soilgrids.org)
|SOC | Predicted topsoil organic carbon content (g/kg) | [SoilGrids](https://soilgrids.org)
|TIM | Topographic index map | [MERITDEM](http://hydro.iis.u-tokyo.ac.jp/~yamadai/MERIT_DEM/)
|WPOP | Population density prediction (2015) | [WorldPop](#http://www.worldpop.org.uk/data/get_data/)
|WPP17 | Population density prediction (2015) | [WorldPop](#http://www.worldpop.org.uk/data/get_data/)

We create a raster object with all these layers. Some Markus files had slighly different projection and extent, I corrected these files in `prepare_rasters.sh`.
```{r}
rasterlist <- list.files(path = "F:/Work/MarkusStacks/ET_250m_2019/ET_500m_2019_resampled/", 
                         pattern = "*.tif$", 
                         full.names = TRUE) # Character vector of relative filepaths

rasterstack <- rast(rasterlist)
```

## 2) Add Latitude and Longitude Rasters
We add longitude and latitude rasters to the stack so that our model considers location in its prediction. The longitude and latitude rasters will have the longitude values and latitude values respectively as the cell values. We use one raster from the stack created earlier as a reference, to ensure the latitude and longitude rasters have the same properties.

Create the longitude and latitude rasters in 5 steps: convert the Tanzania's "level 0" shapefile -downloaded earlier- projection to the Lambert azimuthal equal-area projection; transform it to a raster with the reference raster's properties; extract the longitude and latitude values from the created raster; assign the longitude and latitude values to two copies of the created raster; name the raster cell values and add them to the rasters stack.

This most likely can be done more efficiently with r.latlong in GRASS, but I couldn't make it work.

```{r}
#Extacting longitude and latitude values for each column and row
longitudes <- xFromCol(rasterstack[[1]], 1:dim(rasterstack[[1]])[2]) 
longitudes <- rep(longitudes, times = dim(rasterstack[[1]])[1])
latitudes <- yFromRow(rasterstack[[1]], 1:dim(rasterstack[[1]])[1])
latitudes <- rep(latitudes, times = dim(rasterstack[[1]])[2])
latitudes <- sort(latitudes, decreasing=TRUE)

#Creating the rasters and assigning the values
natbnd.raster.long <- rasterstack[[1]]
values(natbnd.raster.long) <- longitudes
names(natbnd.raster.long) <- "Longitude"  #changing the name of the values
writeRaster(natbnd.raster.long, filename = "F:/Work/MarkusStacks/ET_250m_2019/ET_500m_2019_resampled/long.tif", overwrite=TRUE)

natbnd.raster.lat <- rasterstack[[1]]
values(natbnd.raster.lat) <- latitudes
names(natbnd.raster.lat) <- "Latitude"  #changing the name of the values
writeRaster(natbnd.raster.lat, filename = "F:/Work/MarkusStacks/ET_250m_2019/ET_500m_2019_resampled/lat.tif", overwrite=TRUE)
```

## 3) Creating rasterstack
Let's redo the rasterstack now with the lat long rasters
```{r}
rasterlist <- list.files(path = "F:/Work/MarkusStacks/ET_250m_2019/ET_500m_2019_resampled/", 
                         pattern = "*.tif$", 
                         full.names = TRUE) # Character vector of relative filepaths

rasterstack <- rast(rasterlist)
```


# II. Preparing LSMS market price data
This data is made up of maize prices collectted at various locations across Ethiopia in the 2015-2016 LSMS data. To create this shapefile, we 1) calculate prices in ETB/kg and correcting for the many inaccuracies found in LSMS. 2) Convert all prices to USD/kg using 2016 exchange rate. 3) joining coordinates and 4) creating and saving the shapefile.

This is the LSMS raw data.
```{r }
LSMS <- read.csv("F:/Work/LSMS/ETH_2015_ESS_v03_M_CSV/Community/sect10a2_com_w3.csv")

#Keeping only maize rows
LSMS_maize <- LSMS %>%  filter(cs10a2q01 == "Maize")
```

## 1) Cleaning data and creating prices

Getting the maize prices from the LSMS and correcting for mistakes in the survey. Finally, I convert the prices to USD/kg (using the exchange rate of 2016).
```{r}
table(LSMS_maize$cs10a2q03) #table of units reported in the survey

hist(LSMS_maize$cs10a2q05, main="Histogram of prices reported (not considering units)")

#let's remove all that do not have any price data
LSMS_maize <- LSMS_maize %>% filter(!is.na(cs10a2q05))

#there is one line without quantity. This is most likely 1 because of the price
LSMS_maize$cs10a2q04[212] <- 1

#there is another one that is probably the price for 100kg
LSMS_maize$cs10a2q04[135] <- 100


#Calculating prices per unit
LSMS_maize <- LSMS_maize %>% 
  mutate(maip_ETBkg = cs10a2q05/cs10a2q04)

#Converting those that were reported in grams to kg 
LSMS_maize$maip_ETBkg[LSMS_maize$cs10a2q03 == "Gram"] = LSMS_maize$cs10a2q05[LSMS_maize$cs10a2q03 == "Gram"] / (LSMS_maize$cs10a2q04[LSMS_maize$cs10a2q03 == "Gram"] / 1000)

#Checking distribution of outliers
hist(LSMS_maize$maip_ETBkg[LSMS_maize$maip_ETBkg < 2], main = "very low estimates")
hist(LSMS_maize$maip_ETBkg[LSMS_maize$maip_ETBkg > 15], main = "very high estimates")

#bring back those outliers to original calculation to see if they fit
LSMS_maize$maip_ETBkg[LSMS_maize$maip_ETBkg < 2] <- LSMS_maize$cs10a2q05[LSMS_maize$maip_ETBkg < 2] / LSMS_maize$cs10a2q04[LSMS_maize$maip_ETBkg < 2]
LSMS_maize$maip_ETBkg[LSMS_maize$maip_ETBkg > 15] <- LSMS_maize$cs10a2q05[LSMS_maize$maip_ETBkg > 15] / LSMS_maize$cs10a2q04[LSMS_maize$maip_ETBkg > 15]

#Which lines are still outliers?
LSMS_maize[(LSMS_maize$maip_ETBkg < 2 | LSMS_maize$maip_ETBkg > 15),]

#these most likely reported the quantity in grams erroneously
LSMS_maize$maip_ETBkg[(LSMS_maize$maip_ETBkg < 2 | LSMS_maize$maip_ETBkg > 15)] <- LSMS_maize$cs10a2q05[(LSMS_maize$maip_ETBkg < 2 | LSMS_maize$maip_ETBkg > 15)] / (LSMS_maize$cs10a2q04[(LSMS_maize$maip_ETBkg < 2 | LSMS_maize$maip_ETBkg > 15)]/1000)

#Which lines are still outliers?
LSMS_maize[(LSMS_maize$maip_ETBkg < 2 | LSMS_maize$maip_ETBkg > 15),]

#Let's just remove these values
LSMS_maize <- LSMS_maize %>% filter(maip_ETBkg > 2 & maip_ETBkg < 15)

#Final distribution in ETB/kg
hist(LSMS_maize$maip_ETBkg)

```


## 2) Convert all prices to USD
Conversion from ETB to USD: 2016 exchange rate

```{r}
ETB_to_USD2016 <- 22.5053
LSMS_maize$maip_USDkg <- LSMS_maize$maip_ETBkg/ETB_to_USD2016

#Final distribution in USD/kg
hist(LSMS_maize$maip_USDkg)
```

## 3) Joining coordiantes

Now that we have the list, let's create a shapefile with these values by joining the coordinates found in the other table.

Not all markets have coordinates (in fact only two have them). I'll use mean coordinate by community found in the HH survey as the coordinates for those prices.

```{r }
LSMS_coordinates <- read.csv("F:/Work/LSMS/ETH_2015_ESS_v03_M_CSV/Geovariables/ETH_HouseholdGeovars_y3.csv") %>% 
  dplyr::select(ea_id2, lat_dd_mod, lon_dd_mod)

#remove duplicated lines
LSMS_coordinates <- LSMS_coordinates[!duplicated(LSMS_coordinates),]

#keeping only the mean coordinates for each community
LSMS_coordinates <- LSMS_coordinates %>% group_by(ea_id2) %>% 
  summarize(lat = mean(lat_dd_mod, na.rm=TRUE),
            lon = mean(lon_dd_mod, na.rm=TRUE))

#joining the coordinates
LSMS_maize <- left_join(LSMS_maize, LSMS_coordinates, by = "ea_id2")

#keeeping only those with full coordinates
LSMS_maize <- LSMS_maize %>% filter(!is.na(lat) & !is.na(lon))
```

## 4) Creating spatial object

Now that we have a dataset will full coordinates and prices, I'll create a shapefile to use for predictions

```{r }
#Let's just save ids and prices
LSMS_maize_prices <- LSMS_maize %>% dplyr::select(ea_id2, maip_USDkg)

#creating spatial object with those coordinates
LSMS_maize_vect <- sp::SpatialPointsDataFrame(cbind(LSMS_maize$lon, LSMS_maize$lat),
                                              data = LSMS_maize_prices)
# wgs84.prj: projection for coordinates in prices csv
crs(LSMS_maize_vect) <- "+proj=longlat +datum=WGS84 +no_defs"

#export vector to use for predictions
writeOGR(LSMS_maize_vect,
         dsn = "../../data/prices/ETH_LSMS_market_maize_prices_2016.shp", layer = "maip_USDkg", driver = "ESRI Shapefile")
```

```{r}
ETH_adm <- readOGR("F:/Work/GADM/gadm36_levels_shp/gadm36_ETH_shp/gadm36_ETH_0.shp")
plot(LSMS_maize_vect, pch = 20, col = "Red", main = "Locations With Known Maize Prices")
lines(ETH_adm)
```


The raster files in the Markus stack use [Lambert azimuthal equal-area projection](https://en.wikipedia.org/wiki/Lambert_azimuthal_equal-area_projection), which better preserves areas and distances compared with the WGS84 projection. We transform the projection of the maize price shapefile to match this projection since it must share the same projection system with the rasters in any spatial process.
```{r}
LSMS_maize_vect <- vect("../../data/prices/ETH_LSMS_market_maize_prices_2016.shp")

#Projecting the vector to this projection
LSMS_maize_vect <- terra::project(LSMS_maize_vect, rasterstack)
```

## 5) Extracting values to table: calibration and validation

 prepare the model training data (response variable and prediction variables). The response variable is composed of georeferenced point data and the prediction variables rasters in a stack; we extract values from locations with a response value in the prediction variables to create the training data. A pixel/cell value may include random errors during data collection or processing. To ensure we get a more representational value, we extract the mean of all pixel values within a 5000 meters radius (ground distance) of the response variable location. We remove any columns that have `NA` as the mean (points that fall in areas with no data).
```{r}
dataset <- data.frame(maip_USDkg = LSMS_maize_vect$maip_USDkg)


#extracting values within a raster
dataset = cbind(dataset,
                terra::extract(rasterstack, 
                               LSMS_maize_vect, 
                               buffer=5000, # Meters
                               small=TRUE, 
                               fun = mean))
                

#keeping only points with complete information
dataset.complete <- dataset[complete.cases(dataset),]

# Training/Test set partition ---------------------------------------------
set.seed(1234)
cal <- sample(x = nrow(dataset.complete), size = round(0.8*nrow(dataset.complete))) 

data_cal <- dataset.complete[cal, ] ## calibration data
data_val <- dataset.complete[-cal, ] ## validation data
```

## 6) Exporting tables to files for reading
```{r}
write.csv(data_cal, "../../data/prices/maize_market_price_calibration.csv", row.names=FALSE)
write.csv(data_val, "../../data/prices/maize_market_price_validation.csv", row.names=FALSE)
```


